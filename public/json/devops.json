{
    "devops": [
        {
            "introduction":[
                {"title": "🚀 On-Prem Automated Application Deployment: CI/CD Pipeline Setup Using Azure DevOps – A Proof of Concept"},
                {"meta": "Posted on: June 3, 2025 | By: H.Ragul"},
                {"image": "images/devops.png", "size": 400},
                {"summary": "This blog series will walk you through a proof of concept (PoC) implementation of an automated application deployment pipeline on an on-premises server, using a powerful combination of tools including Azure DevOps, GitHub, Docker, and Kubernetes (k3s). For local infrastructure setup, we’ll be leveraging VMware Workstation Pro to provision virtual machines that will simulate a real-world server environment."},
                {"subtitle": "🎯 Objective"},
                {"content": "Our goal is to build a robust and scalable CI/CD pipeline that can automate the build, test, and deployment of applications on on-prem servers using Azure DevOps. Once we've proven this setup works in an on-premises environment, we will extend the same architecture to Azure Cloud, highlighting how easily DevOps practices can be scaled and migrated."},
                {"subtitle": "🔧 Tech Stack Overview"},
                {"content": "Here’s a quick snapshot of the tools and technologies we’ll be using throughout this series:"},
                {"list": [
                    "Azure DevOps – For CI/CD pipeline management and automation.",
                    "Git & GitHub – Version control and source code management.",
                    "Docker – Containerizing applications for consistent deployment.",
                    "Kubernetes (k3s) – Lightweight Kubernetes distribution for orchestrating deployments.",
                    "VMware Workstation Pro – Local VM provisioning to simulate on-prem infrastructure."
                ]},
                {"subtitle": "📂 What to Expect in This Series"},
                {"content": "This is the first in a series of blogs where we will progressively build and refine the CI/CD pipeline. Here's what you can look forward to:"},
                {"list": [
                    "Environment Setup – Creating VMs with VMware, installing necessary dependencies.",
                    "Source Control Integration – Connecting GitHub repositories with Azure DevOps.",
                    "CI Pipeline Implementation – Automating the build and testing process.",
                    "Dockerization – Building container images from source code.",
                    "CD Pipeline Implementation – Deploying containers to a k3s cluster on-prem.",
                    "Monitoring & Logging – Implementing basic observability tools.",
                    "Cloud Migration – Replicating the entire setup on Azure Cloud."
                ]},
                {"subtitle": "🧪 Why a Proof of Concept?"},
                {"content": "A PoC allows us to validate the design and effectiveness of our DevOps approach in a controlled, local environment. It’s a low-risk way to identify gaps, improve configurations, and build confidence before scaling to production or migrating to the cloud."},
                {"subtitle": "🌐 Ready to Dive In?"},
                {"content": "Whether you're a DevOps engineer looking to explore hybrid deployment strategies or an IT team trying to modernize legacy systems, this series will provide practical insights and step-by-step guidance to build a CI/CD pipeline that works both on-prem and in the cloud."},
                {"content": "Stay tuned for the next blog where we'll begin with setting up the on-prem environment and preparing our VMs for deployment."},
                {"content": "Let’s automate, orchestrate, and innovate—<b>on-prem first, cloud next!</b>"}
            ],

            "environment": [
                {"title": "🛠️ Environment Setup for On-Prem Automated Application Deployment: CI/CD Pipeline with Azure DevOps"},
                {"meta": "Posted on: June 4, 2025 | By: H.Ragul"},
                {"summary": "To achieve a fully automated application deployment in an <b>on-premise</b> environment using a <b>CI/CD pipeline powered by Azure DevOps</b>, the first step is to set up a reliable and scalable <b>local environment</b>. In this blog post, I’ll walk you through how I configured my setup to support this pipeline. This allows for a seamless DevOps experience—<b>without relying on cloud-hosted infrastructure</b> for core pipeline execution. 🚀"},
                {"image": "images/vmware.png", "size": 600},
                {"subtitle": "🧰 Tools and Technologies Used"},
                {"content": "Here’s a quick overview of the tools involved:"},
                {"list": [
                    "💻 <b>VMware Workstation Pro</b> – For creating and managing local virtual machines",
                    "🔧 <b>Azure DevOps</b> – To manage the CI/CD pipeline",
                    "🌐 <b>GitHub</b> – As the centralized version control system",
                    "🐳 <b>Docker</b> – For containerizing and running application components",
                    "☸️ <b>K3s</b> – Lightweight Kubernetes distribution as the deployment target",
                    "🗂️ <b>Git</b> – For source code management on the agent VM"
                ]},
                {"subtitle": "🧱 Local Environment Configuration"},
                {"content": "To simulate a production-like on-prem environment, I set up <b>two virtual machines (VMs)</b> on <b>VMware Workstation Pro</b>. These VMs serve as the foundation of our DevOps infrastructure:"},
                {"subheading": "1️⃣ Agent Server"},
                {"content": "This VM is the workhorse of the CI/CD pipeline:"},
                {"list": [
                    "🤖 <b>Azure DevOps Agent</b>: Installed and configured as a self-hosted runner to execute pipeline jobs locally.",
                    "🐳 <b>Docker</b>: Installed to handle container builds and execution.",
                    "🔗 <b>Git</b>: Set up for source control to enable pulling and pushing code as needed."
                ]},
                {"content": "<i>💡 The agent server runs all major pipeline operations: building, testing, and packaging the app.</i>"},
                {"subheading": "2️⃣ K3s Server"},
                {"content": "This VM acts as the deployment target:"},
                {"list": [
                    "☸️ <b>K3s (Kubernetes lightweight distribution)</b>: Installed to simulate a real Kubernetes cluster in an on-prem setup.",
                    "📦 This is where the final application is deployed once it’s built and tested by the agent."
                ]},
                {"content": "<i>💡 K3s gives us a Kubernetes environment with a smaller footprint—perfect for local testing.</i>"},
                {"subtitle": "🔄 Version Control with GitHub"},
                {"content": "Even though the CI/CD process runs locally, the <b>source code is hosted on GitHub</b>:"},
                {"list": [
                    "🔐 Centralized and secure source control",
                    "🔄 Integrated with Azure DevOps through service connections",
                    "👥 Enables team collaboration and clean version tracking"
                ]},
                {"content": "This hybrid approach keeps the <b>pipeline execution local</b> but uses cloud-based GitHub for version management and collaboration."},
                {"subtitle": "✅ Conclusion"},
                {"content": "With this setup, we now have a <b>fully functional on-prem environment</b> ready for automated deployments using Azure DevOps. This configuration:"},
                {"list": [
                    "Mimics a real production environment 💼",
                    "Offers flexibility and control ⚙️",
                    "Reduces reliance on cloud infrastructure 🌍"
                ]},
                {"content": "Next up, I’ll guide you through configuring the <b>Azure DevOps pipeline</b> itself—connecting it to the agent, building Docker images, and deploying them to the K3s cluster. 🔧📦🚀"},
                {"content": "<b>Stay tuned!</b> 👀"}
            ],
            "activation": [
                {"title": "Agent Server Activation for On-Prem Automated Application Deployment: CI/CD Pipeline with Azure DevOps 🚀"},
                {"meta": "Posted on: June 5, 2025 | By: H.Ragul"},
                {"summary": "In this post, I'll walk you through how I set up the agent server 🖥️. We'll begin with the installation of Docker 🐳 and the Azure DevOps pipeline agent ⚙️. These installations are fairly straightforward, so I’ll simply include the official documentation links below for your reference 📄🔗."},
                {"image": "images/registry.png", "size": 600},
                {"content": "<i>💡 CentOS is used as the operating system for the server setup 🐧</i>"},
                {"content": "Useful Links: <a href='https://docs.docker.com/engine/install/centos/'>Install Docker Engine on CentOS</a> | <a href='https://learn.microsoft.com/en-us/azure/devops/pipelines/agents/windows-agent?view=azure-devops&tabs=IP-V4'>Self-hosted Windows agents</a>"},
                {"subtitle": "🚀 Steps to Set Up a Docker Local Registry"},
                {"subheading": "🛠️ Configure Docker Daemon"},
                {"content": "1. Add the following JSON configuration to the <span className='poppins-light' style='background-color: #1C1D21; color: white; padding: 0 5px;'>/etc/docker/daemon.json</span> file. If the file doesn't exist, create it:"},
                {"code": "{\n 'insecure-registries': ['<your-ip>:8000']\n}"},
                {"content": "2. Restart Docker to apply the changes:"},
                {"code": "systemctl restart docker"},
                {"content": "3. Ensure Docker is running:"},
                {"code": "systemctl status docker"},
                {"subheading": "🗂️ Set Up Local Registry Storage"},
                {"content": "4. Create a directory to store your Docker images:"},
                {"code": "mkdir /registry"},
                {"content": "5. Grant full permissions to the directory:"},
                {"code": "chmod 777 /registry"},
                {"content": "6. Verify the permissions:"},
                {"code": "ls -lrt | grep -i registry"},
                {"content": "<i>💡 Note: The directory can be located anywhere and named as desired. Just make sure to use the correct path in the Docker run command.</i>"},
                {"subheading":"🐳 Run the Local Docker Registry"},
                {"content": "7. Launch the registry container:"},
                {"code": "docker run -d -p 8000:5000 --restart=always --name registry -v /registry:/var/lib/registry registry:latest"},
                {"content": "<i>🔁 Port 5000 (container) is mapped to port 8000 (host).</i>"},
                {"content": "8. Verify that the registry container is running:"},
                {"code": "docker ps"},
                {"content": "9. Test the registry endpoint:"},
                {"code": "curl http://<your-ip>:8000/v2/_catalog"},
                {"content": "✅ Sample output:"},
                {"code": "{'repositories':[]}"},
                {"subtitle": "✅ Conclusion"},
                {"content": "In this setup, I have successfully configured my <b>own local Docker registry</b> 🐳. This allows for efficient local image management and testing 🧪."},
                {"content": "Once local deployment and testing are successful ✅, we will proceed to use the <b>Azure Container Registry (ACR)</b> ☁️🔐 for production or cloud-based deployments."}
            ]
        }
    ]
}